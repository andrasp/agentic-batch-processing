"""Dynamic enumerator for arbitrary Python code execution.

Allows LLM-generated or user-provided Python code to enumerate items from
any data source (APIs, databases, cloud services, etc.).

IMPORTANT: Code execution requires user approval when generated by an LLM.
The approval flow ensures users review code before it runs on their system.
"""

import ast
import sys
import traceback
from io import StringIO
from typing import Any, Dict, Optional

from .base import BaseEnumerator, EnumeratorResult
from .registry import register_enumerator


class PendingApprovalError(Exception):
    """Raised when code requires user approval before execution."""

    def __init__(self, code: str, message: str = "Code requires user approval"):
        self.code = code
        self.message = message
        super().__init__(message)


def validate_syntax(code: str) -> tuple[bool, Optional[str]]:
    """Validate Python code syntax.

    Args:
        code: Python source code

    Returns:
        Tuple of (is_valid, error_message)
    """
    try:
        ast.parse(code)
        return True, None
    except SyntaxError as e:
        return False, f"Syntax error at line {e.lineno}: {e.msg}"


@register_enumerator
class DynamicEnumerator(BaseEnumerator):
    """Enumerate items using custom Python code.

    This enumerator executes arbitrary Python code to enumerate items from
    any data source. The code has full access to Python's capabilities,
    including network requests, database connections, file I/O, etc.

    Configuration:
        code: Python code that defines an `enumerate_items()` function
        context: Optional dict of values to pass to the code
        approved: Whether the code has been approved for execution
        limit: Maximum number of items to return

    The code must define a function:
        def enumerate_items(context: dict) -> list[dict]:
            '''Return list of item dicts.'''
            ...

    Each returned dict becomes a work unit payload.
    The function receives the `context` dict as its argument.

    Security Model:
        - LLM-generated code MUST be approved by the user before execution
        - The MCP server presents the code to the user for review
        - Only after explicit approval does the code run
        - Pre-written/trusted code can set approved=True

    Example - DynamoDB enumeration:
        import boto3

        def enumerate_items(context):
            dynamodb = boto3.resource('dynamodb')
            table = dynamodb.Table(context['table_name'])

            items = []
            response = table.scan()
            for item in response['Items']:
                items.append({
                    'id': item['id'],
                    'data': item
                })

            while 'LastEvaluatedKey' in response:
                response = table.scan(ExclusiveStartKey=response['LastEvaluatedKey'])
                for item in response['Items']:
                    items.append({
                        'id': item['id'],
                        'data': item
                    })

            return items

    Example - REST API enumeration:
        import requests

        def enumerate_items(context):
            items = []
            page = 1

            while True:
                response = requests.get(
                    f"{context['api_url']}/items",
                    params={'page': page, 'per_page': 100},
                    headers={'Authorization': f"Bearer {context['api_token']}"}
                )
                response.raise_for_status()
                data = response.json()

                if not data['items']:
                    break

                for item in data['items']:
                    items.append({
                        'id': item['id'],
                        'url': item['url'],
                        'metadata': item
                    })

                page += 1

            return items
    """

    enumerator_type = "dynamic"
    description = "Enumerate items using custom Python code (requires approval for LLM-generated code)"

    def __init__(self, config: Dict[str, Any]):
        """Initialize dynamic enumerator.

        Args:
            config: Configuration with code, context, and approval status
        """
        self.code = config.get("code", "")
        self.context = config.get("context", {})
        self.approved = config.get("approved", False)
        self.limit = config.get("limit")

    def validate_config(self) -> Optional[str]:
        """Validate configuration."""
        if not self.code:
            return "code is required"

        if not self.code.strip():
            return "code cannot be empty"

        is_valid, error = validate_syntax(self.code)
        if not is_valid:
            return f"Code validation failed: {error}"

        if "def enumerate_items" not in self.code:
            return "Code must define 'enumerate_items(context)' function"

        return None

    def requires_approval(self) -> bool:
        """Check if this enumerator requires user approval before execution."""
        return not self.approved

    def get_code_for_approval(self) -> str:
        """Get the code that needs to be approved."""
        return self.code

    def enumerate(self) -> EnumeratorResult:
        """Execute code and enumerate items.

        Raises:
            PendingApprovalError: If code hasn't been approved yet
        """

        error = self.validate_config()
        if error:
            return EnumeratorResult(success=False, error=error)

        if not self.approved:
            raise PendingApprovalError(
                code=self.code,
                message="Dynamic enumerator code requires user approval before execution. "
                "Review the code and set approved=True to proceed.",
            )

        try:

            exec_globals: Dict[str, Any] = {
                "__builtins__": __builtins__,
                "__name__": "__dynamic_enumerator__",
            }
            exec_locals: Dict[str, Any] = {}

            old_stdout = sys.stdout
            sys.stdout = StringIO()

            try:

                exec(self.code, exec_globals, exec_locals)

                if "enumerate_items" not in exec_locals:
                    return EnumeratorResult(success=False, error="Code did not define 'enumerate_items' function")

                enumerate_func = exec_locals["enumerate_items"]

                result = enumerate_func(self.context)

                if not isinstance(result, list):
                    return EnumeratorResult(
                        success=False, error=f"enumerate_items must return a list, got {type(result).__name__}"
                    )

                items = []
                for idx, item in enumerate(result):
                    if not isinstance(item, dict):

                        item = {"value": item}

                    item = dict(item)
                    item["_index"] = idx

                    items.append(item)

                    if self.limit and len(items) >= self.limit:
                        break

                stdout_output = sys.stdout.getvalue()

                return EnumeratorResult(
                    success=True,
                    items=items,
                    metadata={"item_count": len(items), "stdout": stdout_output if stdout_output else None},
                )

            finally:
                sys.stdout = old_stdout

        except PendingApprovalError:
            raise
        except Exception as e:
            return EnumeratorResult(success=False, error=f"Code execution failed: {str(e)}\n{traceback.format_exc()}")

    def get_sample_item(self) -> Optional[Dict[str, Any]]:
        """Get first item for testing.

        Note: This also requires approval if the code hasn't been approved.
        """
        original_limit = self.limit
        self.limit = 1

        try:
            result = self.enumerate()
        except PendingApprovalError:
            self.limit = original_limit
            raise

        self.limit = original_limit

        if result.success and result.items:
            return result.items[0]
        return None

    @classmethod
    def get_config_schema(cls) -> Dict[str, Any]:
        """Get JSON schema for dynamic enumerator configuration."""
        return {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": (
                        "Python code defining enumerate_items(context) -> list[dict]. "
                        "Has full Python capabilities including network, file I/O, etc. "
                        "LLM-generated code requires user approval before execution."
                    ),
                },
                "context": {
                    "type": "object",
                    "description": "Values passed to enumerate_items() function (API keys, table names, etc.)",
                    "additionalProperties": True,
                },
                "approved": {
                    "type": "boolean",
                    "description": "Whether the code has been approved for execution. Must be True for code to run.",
                    "default": False,
                },
                "limit": {"type": "integer", "description": "Maximum number of items to return", "minimum": 1},
            },
            "required": ["code"],
            "additionalProperties": False,
        }
